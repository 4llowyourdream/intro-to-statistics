---
  title: "Задание"
  description: "Insert the chapter description here"
  v2: true

---
## Выборка и расчет выборочных характеристик

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: f3e9bc7cb4



```

Зачастую неизвестно то, как распределены случайные величины, невозможно наблюдать генеральную совокупность, в связи с чем расчет теоретических характеристик распределения (таких как математическое ожидание, дисперсия и др.) ограничен, не всегда доступен для исследователя в реальной жизни. Однако есть определенная выборка, состоящая из ряда наблюдений какой-либо случайной величины, по которой могут быть рассчитаны выборочные характеристики для:

1. оценки параметров распределения,
2. предсказания результата события.

Итак, сейчас вам предстоит найти несмещенную выборочную дисперсию продолжительности извержения гейзера "Старый Служака" двумя способами. Данный датасет уже доступен в рабочем пространстве под названием `faithful`. Для обращения к столбцу датасета используйте `faithful$name_of_column`.

`@instructions`
- Для вычисления средней продолжительности извержения гейзера "Старый Служака" используйте функцию `mean()`.
- Для подсчета количества наблюдений в датасете используйте функцию `nrow()` (переменная `n` в формуле дисперсии).
- Посчитайте несмещенную выборочную дисперсию продолжительности извержения гейзера (`faithful$eruptions`) **по формуле** с использованием функции `sum()`. Полученный результат сохраните в переменную `var_eval` и выведите на экран значение.
- Посчитайте несмещенную выборочную дисперсию продолжительности извержения гейзера (`faithful$eruptions`) **с помощью функции** `var()`. Полученный результат сохраните в переменную `var_erupt` и выведите на экран значение. Сравните полученные результаты.

`@hint`
Для подсчета несмещенной выборочной дисперсии по формуле необходимо `sum((faithful$eruptions - mean(faithful$eruptions)) ^ 2) / (nrow(faithful) - 1)`.

`@pre_exercise_code`
```{r}
library(datasets)
data("faithful")
```
`@sample_code`
```{r}
#Несмещенная выборочная дисперсия продолжительности извержения гейзера по формуле.
var_eval <- 


#Несмещенная выборочная дисперсия продолжительности извержения гейзера с помощью функции.
var_erupt <-
```
`@solution`
```{r}
#Несмещенная выборочная дисперсия продолжительности извержения гейзера по формуле.
var_eval <- sum((faithful$eruptions - mean(faithful$eruptions)) ^ 2) / (nrow(faithful) - 1)
var_eval

#Несмещенная выборочная дисперсия продолжительности извержения гейзера с помощью функции.
var_erupt <- var(faithful$eruptions)
var_erupt
```
`@sct`
```{r}
test_student_typed("var_eval <- sum((faithful$eruptions - mean(faithful$eruptions)) ^ 2) / (nrow(faithful) - 1)", not_typed_msg = "Что-то не так со значением `var_eval`. Использовали ли вы функцию `sum()` для подсчета несмещенной дисперсии по формуле?")

#fourth instruction
test_student_typed("var_erupt <- var(faithful$eruptions)", not_typed_msg = "Что-то не так со значением `var_erupt`.")
test_output_contains("1.302728", times=2)
test_error()
success_msg("Превосходно! Как мы видим, значения оценки дисперсии, полученные различными способами, совпадают.")
```





---
## Метод моментов

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: a4abd8dbe7



```

**Метод моментов**: теоретические и выборочные моменты совпадают в точке оценки неизвестного параметра.

Оценим среднее время ожидания между извержениями гейзера методом моментов, используя первый начальный момент. Датасет про гейзер "Старый Служака" уже доступен в рабочем пространстве под названием `faithful`.

`@instructions`
- Оцените среднее время ожидания между извержениями гейзера (`faithful$waiting`) методом моментов, используя первый начальный момент.
- Сохраните полученный результат в переменную `mean_time` и выведите ее значение на экран.

`@hint`
Первый начальный момент – это *математическое ожидание* случайной величины, первый выборочный начальный момент – *выборочное среднее*.

`@pre_exercise_code`
```{r}
library(datasets)
data("faithful")
```
`@sample_code`
```{r}
#Оценка среднего времени ожидания между извержениями гейзера с использованием первого начального момента.
mean_time <- 

#Выведите на экран получившееся значение.

```
`@solution`
```{r}
#Оценка среднего времени ожидания между извержениями гейзера с использованием первого начального момента.
mean_time <- mean(faithful$waiting)

#Выведите на экран получившееся значение.
mean_time
```
`@sct`
```{r}
#first instruction
test_function("mean", incorrect_msg = "Что-то не так с `mean_time`. Вызывали ли вы функцию `mean()` для подсчета среднего?")

#second instruction
test_student_typed("mean_time <- mean(faithful$waiting)", not_typed_msg = "Что-то не так с `mean_erupt`.")

#third instruction
test_output_contains("mean_time", incorrect_msg = "Вывели ли вы получившееся значение на экран?")

#General
test_error()
success_msg("Восхитительно! Получилось, что среднее время ожидания между извержениями гейзера примерно 71 минута!")
```





---
## Метод максимального правдоподобия

```yaml
type: PureMultipleChoiceExercise

xp: 50
skills: 1
key: 0ef3cf6ecf



```

Что необходимо знать для того, чтобы использовать для оценки параметра метод максимального правдоподобия (ММП)?


`@hint`
Функция плотности может быть получена из функции распределения случайных величин.





`@possible_answers`
- Выборочное среднее; 
- [Функцию распределения случайных величин;] 
- Оценку параметра методом моментов; 
- Стандартное отклонение.

`@feedbacks`
- Попробуйте еще раз.
- Замечательно! Действительно, для применения ММП необходимо максимизировать функцию правдоподобия, для нахождения которой нужно знать, как случайные величины распределены.
- Попробуйте еще раз.
- Попробуйте еще раз.




---
## Вычисление квантилей

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: dc4fa381af



```

Для того, чтобы посчитать квантили с использованием R, сначала необходимо сгенерировать данные, например из нормального распределения с помощью функции `rnorm()`:

`normal <- rnorm(n, mean, var)`, где **n** – количество генерируемых наблюдений, **mean** – математическое ожидание, **var** – дисперсия.

Затем необходимо применить функцию `quantile(normal, p)`, где **p** – порядок (уровень) квантиля.

**Напоминание**: нормальное распределение с нулевым математическим ожиданием (mean = 0) и единичной дисперсией (var = 1) – стандартное нормальное распределение.
Площадь под графиком функции плотности - вероятность.

`@instructions`
- Сгенерируйте миллион наблюдений из стандартного нормального распределения и сохраните результат в переменную `normal`.
- Посчитайте третий квартиль (0.75-квантиль) с помощью функции `quantile()` для данного распределения.
- Изобразите функцию плотности данного распределения и третий квартиль (0.75-квантиль). 0.75-квантиль будет обозначен красной линией.

`@hint`
Правильно ли вы посчитали третий квартиль `quantile(normal, 0.75)`?

`@pre_exercise_code`
```{r}
library(ggplot2)
```
`@sample_code`
```{r}
#Сгенерируйте миллион наблюдений из стандартного нормального распределения.
normal <- 

#Посчитайте третий квартиль (0.75-квантиль) для данного распределения.
quartile <- 

#Изобразите функцию плотности данного распределения и третий квартиль (0.75-квантиль).
ggplot() + 
  geom_density(aes(normal), fill = "blue", alpha = 0.1) +
  geom_vline(xintercept = quartile, col = "red", size = 1.5)
```
`@solution`
```{r}
#Сгенерируйте миллион наблюдений из стандартного нормального распределения.
normal <- rnorm(1000000, 0, 1)

#Посчитайте третий квартиль (0.75-квантиль) для данного распределения.
quartile <- quantile(normal, 0.75)

#Изобразите функцию плотности данного распределения и третий квартиль (0.75-квантиль).
ggplot() + 
  geom_density(aes(normal), fill = "blue", alpha = 0.1) +
  geom_vline(xintercept = quartile, col = "red", size = 1.5)
```
`@sct`
```{r}
#second instruction
test_student_typed("normal <- rnorm(1000000, 0, 1)", not_typed_msg = "Сгенерировали ли вы миллион наблюдений с `rnorm()`?")
test_student_typed("quartile <- quantile(normal, 0.75)", not_typed_msg = "Обратите внимание на вторую инструкцию. Правильно ли вы посчитали третий квартиль?")

#General
test_error()
success_msg("Отлично! Так держать!")
```





---
## Какой квантиль больше?

```yaml
type: MultipleChoiceExercise
lang: r
xp: 50
skills: 1
key: 6c5bb1e1b1



```

Определите, квантиль какого уровня больше для нормального распределения: 0.05 или 0.1? Почему? Нормальное распределение сгенерировано и доступно в рабочем пространстве под названием `normal`.

`@instructions`
- Квантиль уровня 0.05 больше, чем квантиль уровня 0.1; 
- [Квантиль уровня 0.1 больше, чем квантиль уровня 0.05;] 
- Квантили уровней 0.05 и 0.1 равны.

`@hint`
Чтобы сравнить квантили уровней p1 и p2, используйте следующее выражение: quantile(normal, p1) > quantile(normal, p2)

`@pre_exercise_code`
```{r}
normal <- rnorm(1000000, 0, 1)
```


`@sct`
```{r}
msg1 = "Попробуйте еще раз. Для вычисления квантилей уровня p, используйте функцию quantile(normal, p)."
msg2 = "Прекрасно! Квантиль уровня 0.1 больше для нормального распределения, потому что мы с большей вероятностью попадем левее какого-либо числа (площадь под графиком функции плотности будет больше), если число, квантиль p-ого порядка, будет правее, то есть больше."
msg3 = "Попробуйте еще раз. Для вычисления квантилей уровня p, используйте функцию quantile(normal, p)."
test_mc(2, feedback_msgs = c(msg1, msg2, msg3))
```




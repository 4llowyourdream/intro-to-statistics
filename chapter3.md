---
  title: "Задание"
  description: "Insert the chapter description here"
  v2: true

---
## Выборка и расчет выборочных характеристик

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: f3e9bc7cb4



```

Зачастую неизвестно то, как распределены случайные величины, невозможно наблюдать генеральную совокупность, в связи с чем расчет теоретических характеристик распределения (таких как математическое ожидание, дисперсия и др.) ограничен, не всегда доступен для исследователя в реальной жизни. Однако есть определенная выборка, состоящая из ряда наблюдений какой-либо случайной величины, по которой могут быть рассчитаны выборочные характеристики для:

1. оценки параметров распределения,
2. предсказания результата события.

Итак, сейчас вам предстоит найти несмещенную выборочную дисперсию продолжительности извержения гейзера "Старый Служака" двумя способами. Данный датасет уже доступен в рабочем пространстве под названием `faithful`. Для обращения к столбцу датасета используйте `faithful$name_of_column`.

`@instructions`
- Найдите среднюю продолжительность извержения гейзера "Старый Служака". Полученный результат сохраните в переменную `mean_erupt`;
- Посчитайте количество наблюдений в датасете, для этого используйте функцию `nrow()`. Полученный результат сохраните в переменную `n`; 
- Посчитайте несмещенную выборочную дисперсию продолжительности извержения гейзера (`faithful$eruptions`) **по формуле** с использованием функции `sum()`. Полученный результат сохраните в переменную `var_eval`;
- Посчитайте несмещенную выборочную дисперсию продолжительности извержения гейзера (`faithful$eruptions`) **с помощью функции** `var()`. Полученный результат сохраните в переменную `var_erupt`. Сравните полученные результаты.

`@hint`
Для подсчета несмещенной выборочной дисперсии по формуле необходимо `sum((faithful$eruptions - mean_erupt) ** 2) / (n - 1)`.

`@pre_exercise_code`
```{r}
library(datasets)
data("faithful")
```
`@sample_code`
```{r}
#Посчитайте среднюю продолжительность извержения гейзера "Старый Служака".
mean_erupt <- 

#Посчитайте количество наблюдений в датасете.
n <- 

#Несмещенная выборочная дисперсия продолжительности извержения гейзера по формуле.
var_eval <- 

#Несмещенная выборочная дисперсия продолжительности извержения гейзера с помощью функции.
var_erupt <- 
```
`@solution`
```{r}
#Посчитайте среднюю продолжительность извержения гейзера "Старый Служака".
mean_erupt <- mean(faithful$eruptions) 

#Посчитайте количество наблюдений в датасете.
n <- nrow(faithful)

#Несмещенная выборочная дисперсия продолжительности извержения гейзера по формуле.
var_eval <- sum((faithful$eruptions - mean_erupt) ** 2) / (n - 1)

#Несмещенная выборочная дисперсия продолжительности извержения гейзера с помощью функции.
var_erupt <- var(faithful$eruptions)
```

`@sct`
```{r}
#first instruction
test_student_typed("mean_erupt <- mean(faithful$eruptions)", not_typed_msg = "Что-то не так с `mean_erupt`. Вызывали ли вы функцию `mean()` для подсчета среднего?")

#second instruction
test_student_typed("n <- nrow(faithful)", not_typed_msg = "Что-то не так с `n`.")

#third instruction
test_object("var_eval", incorrect_msg = "Что-то не так со значением `var_eval`. Использовали ли вы функцию `sum()` для подсчета несмещенной дисперсии по формуле?")

#fourth instruction
test_object("var_erupt", incorrect_msg = "Что-то не так со значением `var_erupt`.")

#General
test_error()
success_msg("Превосходно! Как мы видим, значения оценки дисперсии, полученные различными способами, совпадают.")
```


---
## Метод моментов

```yaml
type: NormalExercise
key: a4abd8dbe7
lang: r
xp: 100
skills: 1
```
**Метод моментов**: теоретические и выборочные моменты совпадают в точке оценки неизвестного параметра.

Оценим среднее время ожидания между извержениями гейзера методом моментов, используя первый начальный момент. Датасет про гейзер "Старый Служака" уже доступен в рабочем пространстве под названием `faithful`.


`@instructions`
- Оцените среднее время ожидания между извержениями гейзера (`faithful$waiting`) методом моментов, используя первый начальный момент.
- Сохраните полученный результат в переменную `mean_time` и выведите ее значение на экран.


`@hint`
Первый начальный момент – это *математическое ожидание* случайной величины, первый выборочный начальный момент – *выборочное среднее*.

`@pre_exercise_code`
```{r}
library(datasets)
data("faithful")
```

`@sample_code`
```{r}
#Оцека среднего среднего времени ожидания между извержениями гейзера с использованием первого начального момента.
mean_time <- 

#Выведите на экран получившееся значение

```

`@solution`
```{r}
#Оцека среднего среднего времени ожидания между извержениями гейзера с использованием первого начального момента.
mean_time <- mean(faithful$waiting)

#Выведите на экран получившееся значение
mean_time
```

`@sct`
```{r}
#first instruction
test_function("mean", incorrect_msg = "Что-то не так с `mean_time`. Вызывали ли вы функцию `mean()` для подсчета среднего?")

#second instruction
test_student_typed("mean_time <- mean(faithful$waiting)", not_typed_msg = "Что-то не так с `mean_erupt`.")

#third instruction
test_output_contains("mean_time", incorrect_msg = "Вывели ли вы получившееся значение на экран?")

#General
test_error()
success_msg("Отлично! Так держать!")
```
---
## Метод максимального правдоподобия

```yaml
type: PureMultipleChoiceExercise

xp: 50
skills: 1
key: 0ef3cf6ecf



```

Что необходимо знать для того, чтобы использовать для оценки параметра метод максимального правдоподобия (ММП)?


`@hint`
Функция плотности может быть получена из функции распределения случайных величин.





`@possible_answers`
- Выборочное среднее; 
- [Функцию распределения случайных величин;] 
- Оценку параметра методом моментов; 
- Стандартное отклонение.

`@feedbacks`
- Попробуйте еще раз.
- Замечательно! Действительно, для применения ММП необходимо максимизировать функцию правдоподобия, для нахождения которой нужно знать, как случайные величины распределены.
- Попробуйте еще раз.
- Попробуйте еще раз.





---
## Вычисление квантилей

```yaml
type: NormalExercise
key: dc4fa381af
lang: r
xp: 100
skills: 1
```
Для того, чтобы посчитать квантили с использованием R, сначала необходимо сгенерировать данные, например из нормального распределения с помощью функции `rnorm()`:

`normal <- rnorm(n, mean, var)`, где **n** – количество генерируемых наблюдений, **mean** – математическое ожидание, **var** – дисперсия.

Затем необходимо применить функцию `quantile(normal, p)`, где **p** – порядок (уровень) квантиля.

**Напоминание**: нормальное распределение с нулевым математическим ожиданием (`mean = 0`) и единичной дисперсией (`var = 1`) – стандартное нормальное распределение.
Площадь под графиком функции плотности - вероятность.


`@instructions`
- Сгенерируйте сто тысяч наблюдений из стандартного нормального распределения и сохраните результат в переменную `normal`.
- Посчитайте третий квартиль (0.75-квантиль) с помощью функции `quantile()` для данного распределения.
- Изобразите функцию плотности данного распределения и третий квартиль (0.75-квантиль).


`@hint`
Правильно ли вы посчитали третий квартиль `quantile(normal, 0.75)`?

`@pre_exercise_code`
```{r}
library(ggplot2)
```

`@sample_code`
```{r}
#Сгенерируйте сто тысяч наблюдений из стандартного нормального распределения.
normal <- 

#Посчитайте третий квартиль (0.75-квантиль) для данного распределения.
quartile <- 

#Изобразите функцию плотности данного распределения и третий квартиль (0.75-квантиль).
ggplot() + 
  geom_density(aes(normal), fill = "blue", alpha = 0.1) +
  geom_vline(xintercept = quartile, col = "red", size = 1.5)
```

`@solution`
```{r}
#Сгенерируйте сто тысяч наблюдений из стандартного нормального распределения.
normal <- rnorm(100000, 0, 1)

#Посчитайте третий квартиль (0.75-квантиль) для данного распределения.
quartile <- quantile(normal, 0.75)

#Изобразите функцию плотности данного распределения и третий квартиль (0.75-квантиль).
ggplot() + 
  geom_density(aes(normal), fill = "blue", alpha = 0.1) +
  geom_vline(xintercept = quartile, col = "red", size = 1.5)
```

`@sct`
```{r}
#first instruction
test_object("normal", incorrect_msg = "Что-то не так с `normal`. Сгенерировали ли вы сто тысяч наблюдений с помощью функции `rnorm()`?")

#second instruction
test_student_typed("quartile <- quantile(normal, 0.75)", not_typed_msg = "Обратите внимание на вторую инструкцию. Правильно ли вы посчитали третий квартиль?")

#General
test_error()
success_msg("Отлично! Так держать!")
```
---
## Какой квантиль больше?

```yaml
type: MultipleChoiceExercise
lang: r
xp: 50
skills: 1
key: 6c5bb1e1b1



```

Определите, квантиль какого уровня больше для нормального распределения: 0.05 или 0.1? Почему? Нормальное распределение сгенерировано и доступно в рабочем пространстве под названием `normal`.

`@instructions`
- Квантиль уровня 0.05 больше, чем квантиль уровня 0.1; 
- [Квантиль уровня 0.1 больше, чем квантиль уровня 0.05;] 
- Квантили уровней 0.05 и 0.1 равны.

`@hint`
Чтобы сравнить квантили уровней p1 и p2, используйте следующее выражение: quantile(normal, p1) > quantile(normal, p2)

`@pre_exercise_code`
```{r}
normal <- rnorm(1000000, 0, 1)
```


`@sct`
```{r}
msg1 = "Попробуйте еще раз. Для вычисления квантилей уровня p, используйте функцию quantile(normal, p)."
msg2 = "Превосходно! Квантиль уровня 0.1 больше для нормального распределения, потому что мы с большей вероятностью попадем левее какого-либо числа (площадь под графиком функции плотности будет больше), если число, квантиль p-ого порядка, будет правее, то есть больше."
msg3 = "Попробуйте еще раз. Для вычисления квантилей уровня p, используйте функцию quantile(normal, p)."
test_mc(2, feedback_msgs = c(msg1, msg2, msg3))
```



